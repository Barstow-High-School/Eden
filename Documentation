int Leftm = // left motor port
int Rightm = // right motor port
int Claw = // claw servo port
int Arm = // arm servo port

int Leftb = // back left button port
int Rightb = // back right button port
int Frontb = // front bar button port

int Starts = // start on light sensor port
int Downs = // downward light sensor port
int Fronts = // frontward light sensor port


float Armlength = // arm length in inches
float Armoffsety = // vertical arm offset in inches
float Armoffsetx = // horizontal arm offset in inches

float Botoffsetx = // bot offset in inches (roomba starting box is 0,0)
float Botoffsety = // the center of the wheels "axel" is the bot position

float LMM = // if a motor is drifting, adjust this number accordingly
float RMM = // if its drifting to the left, lower the right motor multiplier
float timemult = // multiplies time in order to adjust for distance loss

float WheelRadius = // radius of the wheel in inches
float AxelRadius = // radius of the axel in inches
float TurnRate = //axel radius / wheel radius

float CurrentO = // robot's orientation relative to global setup
float CurrentX = // robot's X relative to global setup
float CurrentY = // robot's Y relative to global setup

int AthenaOn = // disables pathfinding if its draining too many recources
float athenaMargin = // margin of error in which math is chosen, higher for less recourses, lower for more precision
    
    
    
    
    
    
    
float absolute(float);
// in (value)
// Get the absolute value of an input
// abs() wasnt working for whatever reason idk
// out (absolute value)

void CollisionCheck();
// Checks if the robot is attempting to move and failing
// WIP (need to check the Gs in the direction its not going)

void CollisionReset();
// Brings the robot to face the south wall and the west wall in order to find
// the location of the colision

void CollisionRecovery(float, float, float);
// in (x offset, y offset, angular offset)
// Brings the robot to the point of collision, with an optional offset ((0,0,0)
// for no offset.)

void AthenaDecision(float, float);
// in (left delta, right delta)
// decides which method of position/orientation calculation to preform

void AOPivot(float, float);
// in(Delta L, Delta R)
// calculates the change in orientation of the robot given a pivot

void APCount(float, float);
// in(Delta L, Delta R)
// calculates the change position given a straight movement

void APOTrig(float, float);
// in(Delta L, Delta R);
// calculates the change in position given complex deltas

void AOCalc(float);
// calculates the new orientation given the previous orientation and the change
// from previous orientation

void APCalc(float, float);
// calculates the new position given the previous orientation and the previous
// location, as well as the delta orientation and delta position

void Status(char hex[]);
// in (hexadecimal string which prints a set of chosen values)
/*
Type the function like this
hex[0] = 'F';
hex[1] = 'F';
hex[2] = 'F';
Status(hex);
*/
// OXY/Athena, Battery, Motor positions, Accelerometer, Gyro, Compass, Motor
// Multipliers, Servo Positions, Enabled Servos, Digitals, Analogs,
// CommandCalls(updates until further notice) hex value will be 3 characters
// (use https://www.rapidtables.com/convert/number/binary-to-hex.html) FFF
// prints all values 000 prints none prints the current state of the robot
// out(orientation, position, sensor values, wheel positions, servo
// positions, etc)

int MOE(float, float, float);
// in (value one, value two, range)
// calculates if value one is within a certain range of value two
// out (1 if values are within range, 0 if not)

void Test(int, int, int);
// calculates the values needed to preform a given movement
// ie. "go straight for 3 seconds"

void ArmVertical(float, float);
// in (goal position, time)
// locks the arm on the z axis as it attempts to go from the current position to
// the goal position

float rad(float);
// in (degrees)
// converts degrees to radians
// math.h's was busted idk
// out (radians)

float degrees(float);
// in (radians)
// converts radians to degrees
// out (degrees)

void Velocity();
// calculates the current velocity of each wheel in powerpercent

int clamp(float, float, float);
// in (min, val, max)
// checks that a value is within the minimum and maximum value
// out (1 true, 0 false)

void TankSpeed(float, float, float);
// in (left speed, right speed, time)
// moves the wheels independently at a certain speed for a certain amount of
// time

void TankRotation(float, float, float);
// in (left wheel goal, right wheel goal, time)
// moves the wheels independently to a goal position in a certain amount of time

void TankDistance(float, float, float);
// in (left wheel goal, right wheel goal, time)
// moves the wheels independently to a goal position in a certain amount of time

void DriveSpeed(float, float, float);
// in (base speed, turn percent, time);
// moves the wheels together at a certain speed for a certain amount of time

void DriveRotation(float, float, float);
// in (base rotations, turn rotations, time);
// moves the wheels together to a goal position in a certain amount of time

void DriveDistance(float, float, float);
// in (base distance, turn distance, time);
// moves the wheels together to a goal position in a certain amount of time

void TankAccelerate(float, float, int);
// in (left goal, right goal, acceleration value)
// moves the wheels independently, going faster over time

void DriveAccelerate(float, float, int);
// in (base speed goal, turn speed goal, acceleration value)
// moves the wheels together, going faster over time

void SmoothTankTime(float, float, float, float, int, float);
// in (first left acceleration goal, first right acceleration goal, second left
// acceleration goal, second right acceleration goal, 	acceleration value, how
// long to move at first goal) moves from current speed to a new goal, stays at
// the goal for a certain amount of time, and then goes from that goal to the
// second goal

void SmoothDriveTime(float, float, float, float, int, float);
// in (first base acceleration goal, first turn acceleration goal, second base
// acceleration goal, second turn acceleration goal, 	acceleration value, how
// long to move at first goal) moves from current speed to a new goal, stays at
// the goal for a certain amount of time, and then goes from that goal to the
// second goal

void SetArm(float, float);
// in (arm goal, claw goal)
// sets the arm and claw to a goal position

void ChangeArm(float, float);
// in (delta arm position, delta claw position)
// changes the arm from the current position to the goal position

void SlowSetArm(float, float);
// in (goal arm position, time)
// goes to the goal arm position in a certain amount of time

int DTTW(float);
// in (Degrees)
// converts degrees to wheel ticks
// out (Ticks)

float TTDW(int);
// in (Ticks)
// converts wheel ticks to degrees
// out (Degrees)

float DTIW(float);
// in (Degrees)
// converts wheel degrees to inches
// out (Inches)

float ITDW(float);
// in (Inches)
// converts inches to wheel degrees
// out (Degrees)

float TTIW(int);
// in (Ticks)
// converts wheel ticks into inches
// out (Inches)

int ITTW(float);
// in (Inches)
// converts inches to wheel ticks
// out (Ticks)

int DTTA(float);
// in (Degrees)
// converts degrees to arm tics
// out (Tics)

float TTDA(int);
// in (Tics)
// converts arm tics to degrees
// out (Degrees)

int DTTC(float);
// in(Degrees)
// converts degrees to claw tics
// out(Tics)

float TTDC(int);
// in(Tics)
// converts claw tics to degrees
// out(Degrees)

void Wait(float);
// in (seconds)
// a pause

void Brake();
// employs braking in both wheels

void CMR();
// clears motor tick counters

void HandsOff();
// initiates wait for light program
// stop touching the robot!

void Startup();
// initiates system resets, prepares the robot to run